你正在一个系统级项目中工作。
该项目由多个模块组成，具有明确的前后端边界，
需要长期维护与持续迭代。

项目结构：
- 前端：client（React）
- 后端：server（Go）

========================
核心原则（最高优先级）
========================
- 代码可读性高于一切。
- 优先选择直观、明确、易理解的实现方式。
- 可读性优先于性能、技巧和复杂抽象。
- 代码应在无需额外说明的情况下被理解。

========================
通用修改原则
========================
- 所有修改必须有明确目的。
- 避免无关重构和顺手优化。
- 严格遵循既定的目录结构与职责划分。
- 修改应保持克制，避免影响不相关模块。

========================
目录与职责边界
========================
必须严格遵守目录职责，不得跨界。

------------------------
server（Go 后端）
------------------------
后端为一个系统级 Go 项目，
强调清晰分层、职责边界与长期可维护性。

========================
整体目录层级约定
========================
server/
├── config/          # 配置结构定义
├── global/          # 全局配置与全局对象
├── core/            # 核心服务启动（如 Gin）
├── initialize/      # 初始化逻辑
├── internal/        # 业务内部实现
├── *.yaml / *.yml   # 配置文件（与 main.go 同级）
└── main.go

配置文件约定：
- 配置文件直接放置在 server 根目录。
- 禁止在子目录中散落配置文件。
- 所有配置文件仅在 initialize 层加载一次。
- 禁止在 handler / service / repository 中直接读取配置文件。
- 业务代码只能通过 global 层访问已加载的配置实例。

========================
各层职责说明
========================

config（配置定义层）：
- 定义配置结构体（如 AppConfig、DBConfig、RedisConfig）。
- 负责配置项结构与校验规则的表达。
- 不负责文件读取或环境判断。
- 不依赖任何业务代码。

global（全局对象层）：
- 存放全局配置实例（如 global.Config）。
- 存放全局基础对象：
  - Logger
  - DB 连接
  - Cache 客户端
- 仅用于全局共享资源的集中管理。
- 禁止编写任何业务逻辑。

core（核心服务层）：
- 创建并运行核心服务（如 Gin Engine）。
- 注册全局中间件与路由入口。
- 不承载业务逻辑。
- 不直接操作数据库或业务 Service。

initialize（初始化层）：
- 系统启动阶段的初始化逻辑：
  - 读取 server 根目录下的配置文件
  - 解析并注入 global.Config
  - 初始化日志、数据库、缓存等基础设施
  - 初始化中间件
  - 注册路由
- 初始化代码应按依赖顺序拆分。
- 仅在程序启动阶段使用。

========================
internal（业务内部实现）
========================
internal 目录存放所有业务相关代码，
不对外暴露，仅供 server 内部使用。

------------------------
internal 内部分层规则
------------------------

handler/（或 controller/）：
- 只负责：
  - 请求解析
  - 基础参数校验
  - 调用 Service
  - 返回响应结果
- 禁止：
  - 直接操作数据库
  - 编写业务规则
- 仅依赖 Service 层与 internal/types 中的请求结构体。

service/：
- 业务逻辑集中层。
- 表达业务规则与业务流程。
- 可组合多个 Repository / Query 完成业务操作。
- 不依赖：
  - HTTP 请求对象
  - Web 框架（Gin / Echo 等）

repository/ 或 dao/：
- 数据访问层。
- 仅负责数据库 CRUD 操作。
- 不包含业务逻辑。

query/：
- 查询封装层。
- 用于复杂查询、多表查询、只读查询。
- 不包含业务决策。

model/：
- 数据模型定义层。
- 定义数据库映射结构与领域对象。
- 不包含业务逻辑。

types/：
- 请求与响应结构体定义层。
- 存放：
  - Handler 层使用的请求参数结构体（DTO）
  - 响应数据结构体
- 用于参数绑定与返回结果表达。
- 不包含业务逻辑。
- 不依赖 Service、Repository 或 Web 框架。

middleware/：
- 中间件层。
- 存放 HTTP 中间件（鉴权、日志、限流等）。
- 仅处理横切关注点。
- 不包含业务逻辑。

========================
internal 层通用约束
========================
- handler 只依赖 service 与 types。
- service 只依赖 repository / query / model。
- repository / query 只依赖 model 与数据库基础设施。
- types 不依赖任何业务实现层。
- 禁止反向依赖和跨层调用。


========================
后端分层通用约束
========================
- 严禁跨层调用（如 handler → repository）。
- 严禁循环依赖。
- HTTP 相关内容不得渗透到 service、repository、model。
- 配置加载只能发生一次，且只能发生在 initialize 层。
- global 层只做“容器”，不做“决策”。

------------------------
client（React 前端）
------------------------
前端为一个处于开发阶段的系统项目，允许建设性设计与结构补充。
项目以“可读性与可维护性”为最高优先级。

技术栈与工具约定：
- React 版本：18.x
- 构建工具：Vite
- 包管理工具：pnpm
- UI 组件库：Ant Design 5.x
- CSS 方案：
  - 主要使用 TailwindCSS
  - 支持全局 CSS 文件（如 reset、变量定义）
- HTTP 请求库：Axios
- 状态管理：Zustand
- 工具 Hooks 库：ahooks

========================
src 目录结构与职责
========================

- api/
  - 存放所有基于 Axios 的请求相关代码
  - 统一维护 Axios 实例、拦截器和接口方法
  - 禁止在组件、hooks、store 中直接创建 Axios 实例
  - 禁止在 UI 组件中编写请求逻辑

- components/
  - 存放可复用的 UI 组件
  - 优先基于 Ant Design 组件进行二次封装
  - 组件只负责展示，不包含业务流程逻辑
  - 不直接发起网络请求
  - 不直接依赖全局状态

- hooks/
  - 存放自定义 React Hooks
  - 可基于 ahooks 进行组合封装
  - 用于抽离和复用业务逻辑或交互逻辑
  - 可组合 api、store、React 内建 Hooks
  - 禁止包含 JSX 或 UI 渲染代码

- router/
  - 存放路由相关配置
  - 使用 React Router（版本不作强制限制）
  - 负责页面路由定义、权限控制、路由守卫等
  - 不承载具体业务逻辑

- store/
  - 全局状态管理层
  - 统一使用 Zustand
  - Store 按业务域拆分，保持单一职责
  - 禁止出现“万能全局 store”
  - 状态变更必须通过显式 action 方法完成

- types/
  - 存放 TypeScript 类型、接口、枚举定义
  - 用于描述数据结构、接口返回值、业务对象
  - 禁止在此处编写任何业务或工具逻辑

通用约束：
- UI 组件不直接依赖 api 层。
- 网络请求只允许出现在 api 层或 hooks 中。
- 业务流程应由页面组件或 hooks 组合完成。
- 状态修改必须通过 store 暴露的接口完成。
- 严禁跨层滥用（如 components 直接操作 api 或 store）。


========================
代码风格与可读性
========================
Go：
- 使用 gofmt 保持统一格式。
- 代码应直白、线性，避免复杂控制流和过深嵌套。
- 优先可读性，而非技巧性实现。

错误处理：
- 优先使用 Go 标准库 errors 包进行错误处理。
- 错误必须显式处理，禁止忽略 error。
- 错误应具备清晰语义，能够表达“发生了什么问题”。

- 避免过度包装错误：
  - 不得多层嵌套 fmt.Errorf("%w")。
  - 不得为了形式规范而重复包装同一个错误。
  - 如果原始错误已足够清晰，应直接返回。

- 仅在“确实增加业务上下文”时，才允许包装错误：
  - 上下文应体现业务含义，而非技术细节。
  - 通常只允许一层包装。

- 错误判断应使用 errors.Is / errors.As。
- 禁止通过字符串比较判断错误类型。

- 对于可预期的业务错误：
  - 应定义明确的哨兵错误（sentinel error）。
  - 业务层可直接返回该错误，不做无意义包装。

React / TypeScript：
- 使用函数式组件与 Hooks。
- 类型定义清晰、明确。
- JSX 结构清晰，避免过深嵌套。
- 不为潜在复用提前抽象。

========================
注释规范（简约）
========================
- 注释用于说明功能，而非实现细节。
- 优先模块和函数级注释。
- 禁止逐行解释代码。
- 能通过命名说明的，不写注释。

========================
依赖与工具
========================
- 新增依赖需有明确价值。
- 避免引入功能重叠或增加理解成本的库。

========================
项目结构与设计说明
========================
- 项目结构说明、模块划分、设计约定等内容，
  必须使用 Markdown（.md）文件进行编写和维护。

- 不在代码中通过大量注释说明项目结构或设计背景。
- 不在代码中描述整体架构、目录职责或系统级规则。

- Markdown 文档主要用于：
  - 项目整体结构说明
  - 模块职责划分
  - 重要设计决策与约定
  - 跨模块协作规则

- 代码注释仅用于解释当前模块或函数的功能，
  不承担系统设计说明职责。

- 当发现需要“解释一段背景或设计原因”时，
  应优先补充或更新对应的 Markdown 文档，
  而不是增加代码注释。


========================
输出要求
========================
- 提供的代码应可直接运行或编译。
- 不假设用户会补充缺失逻辑。
- 如存在权衡或风险，应明确说明。
